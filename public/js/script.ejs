<script type="text/javascript">
    //  Initial values
    var valueBTC = valueETH = valueYODA = 0,
        summBTCA = summETHA = summYODAA = 0, 
        summBTCA = summETHA = summYODAA = 0,
        summBTCB = summETHB = summYODAB = 0,
        summBTCP = summETHP = summYODAP = 0,
        ethPriceBTC = ethPriceUSD = YODAPrice = 0,
        nStr = stepN = orderID = 0,
        timeNow = "";

    function nextStep() {
        stepN = stepN + 1;
        document.getElementById('ind').value = stepN;
        if (stepN == 1) {
            showMess("Smart contract DEx: startDEx in progress");
            document.getElementById('bobStatus').innerText = "Filling order: smart contract DEx in progress";
            document.getElementById('aliceStatus').innerText = "Filling order: smart contract DEx in progress";
            startDEx();
        } else if (stepN == 2) {
            var ff = semafor(1, 0, 0);
            showMess('Alice makes pledge Tx in YODAs');
            var tx = makeYODATX('alice','plasmoid', valueYODA);
        } else if (stepN == 3) {
            var ff = semafor(0, 1, 0);
            showMess('Bob makes pledge Tx in YODAs');
            var tx = makeYODATX('bob', 'plasmoid', valueYODA);
        } else if (stepN == 4) {
            showBalances();
            showMess('Smart contract DEx: inDepo in progress');
            callDExIn();
        } else if (stepN == 5) {
            var ff = semafor(1, 1, 0);
            showMess('Alice & Bob make two atomic swap Tx');
            atomicSwap();
        } else if (stepN == 6) {
            var ff = semafor(0, 0, 1);
            showBalances();
            document.getElementById('aliceStatus').innerText = "Alice received " + valueETH.toFixed(3) + " ETH";
            showMess("Atomic swap BTC/ETH in progress, waiting for BTC Tx confirmation");
        } else if (stepN == 7) {
            var ff = semafor(0, 0, 1);
            showBalances();
            showMess('Atomic swap is finished. Plasmoid makes Tx to cancel pledges');
            var tx = makeYODATX(addrsETHP, ethPrivateKeyP, addrsETHA, valueYODA);
            showMess('Plasmoid sends ' + valueYODA.toFixed(3) + ' YODAs to Alice');
            document.getElementById('bobStatus').innerText = "Bob received " + valueBTC.toFixed(6) + " BTC";
            sendTx(addrsETHP, addrsETHA, tx);
        } else if (stepN == 8) {
            showMess("Plasmoid makes Tx to cancel Bobs pledge");
            var tx = makeYODATX(addrsETHP, ethPrivateKeyP, addrsETHB, valueYODA);
            showMess('Plasmoid sends ' + valueYODA.toFixed(3) + ' YODAs to Bob');
            sendTx(addrsETHP, addrsETHB, tx);
        } else if (stepN == 9) {
            showMess('Smart contract DEx: outDepo in progress');
            callDExOut();
        } else if (stepN == 10) {
            var ff = semafor(0, 0, 0);
            showBalances();
            showMess("Atomic swap BTC/ETH finished successfully!");
        }
    };

    //  YODA functions  

    function startDEx() {
        if (isYODAApi) {
            showMess('Smart contract DEx: form and send startDEx Tx');
            var jsonData = JSON.stringify({ valueA: valueBTC, valueB: valueETH, valueY: valueYODA})
            $.get(hostYODAApi + 'startDEX/' + jsonData)
                .then(function(d) {
                    showMess('Smart contract DEx: startDEx Tx is successful');
                    orderID = d.id
                    console.log('order=' + d.id + ' from ' + d.maker + ' to ' + d.taker + ' via: ' + d.plasmoid + ' eth: ' + d.ethAmount / 10 ** 18 + ' btc: ' + d.btcAmount / 10 ** 8 + ' pledge (YODA): ' + d.pledgeYODAAmount / 10 ** 9);
                    nextStep();
                })
                .fail(function(err) {
                    console.log(err.status + err.responseText)
                })

        }
     else {
        }
    }

    function makeYODATX(from, to, summ) {
        if (isYODAApi) {
            var jsonData = JSON.stringify({ from: from, to: to, valueY: summ})
            $.get(hostYODAApi + 'makeTX/' + jsonData)
                .then(function(d) {
                    showMess("Transfer " + from + "'s" + " YODAs Tx is successful");
                    console.log('hash Tx=' + d.hash);
                    nextStep();
                })
                .fail(function(err) {
                    console.log(err.status + err.responseText)
                })

        }
     else {
        }
 
    }


    function callDExIn() {
        return;
        var filter = DExContract.InDepo({
            _order: orderID
        });
        filter.watch(function(err, event) {
            if (!err) {
                showMess('Smart contract DEx: inDepo Tx is successful');
                filter.stopWatching();
                console.log('order = ' + event.args._order);
                nextStep();
            } else {
                console.log("Error " + err)
            };
        });
        showMess('Smart contract DEx: form and send inDepo Tx, orderID= ' + orderID);
        var accountFrom = addrsETHP; //  Test RPC!!!
        var privateKey = ethPrivateKeyP;
        var myCallData = DExContract.inDepo.getData(orderID); // Data for Ethereum transaction call smart contract DEx
        var accountTo = DExAddrs;
        var countTx = YODA3.eth.getTransactionCount(accountFrom);
        var txParams = {
            nonce: countTx,
            gasPrice: gasPrice,
            gasLimit: gasLimit,
            to: accountTo,
            value: value0,
            data: myCallData
            // EIP 155 chainId - mainnet: 1, ropsten: 3, 1337 - private
            //chainId: 1337
        }
        var tx = new EthJS.Tx(txParams);
        tx.sign(privateKey);
        var serializedTx = tx.serialize()
        YODA3.eth.sendRawTransaction('0x' + serializedTx.toString('hex'));
    }

    function callDExOut() {
        var filter = DExContract.OutDepo({
            _order: orderID
        });
        filter.watch(function(err, event) {
            if (!err) {
                showMess('Smart contract DEx: OutDepo Tx is successful');
                filter.stopWatching();
                console.log('order = ' + event.args._order);
                nextStep();
            } else {
                console.log("Error " + err)
            };
        });
        showMess('Smart contract DEx: form and send OutDepo Tx');
        var accountFrom = addrsETHP;
        var privateKey = ethPrivateKeyP;
        var myCallData = DExContract.outDepo.getData(orderID, addrsETHP);
        var accountTo = DExAddrs;
        var countTx = YODA3.eth.getTransactionCount(accountFrom);
        var txParams = {
            nonce: countTx,
            gasPrice: gasPrice,
            gasLimit: gasLimit,
            to: accountTo,
            value: value0,
            data: myCallData,
            // EIP 155 chainId - mainnet: 1, ropsten: 3, 1337 - private
            chainId: 1337
        }
        var tx = new EthJS.Tx(txParams);
        tx.sign(privateKey);
        var serializedTx = tx.serialize()
        YODA3.eth.sendRawTransaction('0x' + serializedTx.toString('hex'));
    }


    //  Atomic swap function
    function atomicSwap() {
        showMess('Alice send ' + valueBTC.toFixed(6) + 'BTC to Bob Tx to Bitcoin');
        makeBTCTx(addrsBTCA, wifPrivateKeyA, addrsBTCB, valueBTC * 10 ** 8, function(txHash) {
            showMess('BTC Tx is successful. Checking Bitcoin confirmation');
            console.log('BTC Tx hash: ' + txHash);
            var ff = semafor(3, 0, 1);
            waitConfirmBtc(txHash);
            /*            param = '?a=' + txHash //addrsFrom.toString();
                        $.post('/dex/checkTx' + param).done(function(ls) {
                            if (ls !== 'error') {
                                showMess('BTC Tx is confirmed in block ' + ls);
                                nextStep();
                            } else {
                                showMess('Error while BTC confirmation: no Tx mined in 30 min')
                            };
                        }).fail(function(xhr) {
                            showMess(xhr.responseText);
                        }); */
        });
        var tx = makeEthTX(addrsETHB, ethPrivateKeyB, addrsETHA, valueETH);
        showMess('Bob send ' + valueETH.toFixed(3) + 'ETH Tx to Ethereum');
        Eth3.eth.sendRawTransaction(tx, function(err, hash) {
            if (!err) {
                var ff = semafor(0, 3, 1);
                showMess('ETH Tx is success. Checking Ethereum confirmation');
                console.log('ETH Tx hash: ' + hash);
                waitConfirmEth(hash);
            } else
                showMess('Error while ETH Tx sends: ' + err);
        });
    }

    //  Bitcoin functions

    function makeBTCTx(addrsFrom, wifPrivateKey, addrsTo, value, callBack) {
        param = '?a=' + addrsFrom;
        param = param + '&b=' + addrsTo;
        //        valueBTC = document.getElementById('l_pct').value;
        param = param + '&c=' + value.toString();
        param = param + '&d=' + wifPrivateKey;
        $.post('/dex/tx' + param).done(function(ls) {
            console.log(ls);
            callBack(ls);
        }).fail(function(xhr) {
            showMess('Error while BTC Tx sends: ' + xhr.responseText);
        });
    }

    function waitConfirmBtc(hash) {
        var interval;
        var timeOut = setTimeout(function() {
            clearInterval(interval);
            showMess('Error while mining BTC Tx in next 30 minuts');
        }, 1800000);
        interval = setInterval(function() {
            $.get(hostBtc + '/txs/' + hash)
                .done(function(tx) {
                    if (tx.confirmations > 0) {
                        showMess('BTC Tx is confirmed in block ' + tx.block_height.toString());
                        clearTimeout(timeOut);
                        clearInterval(interval);
                        nextStep();
                    } //else //console.log(tx)
                })
                .fail(function(err) {
                    showMess('Error while mining BTC Tx: ' + err);
                })
        }, 30000);
    }

    //  Ethereum functions

    function makeEthTX(accountFrom, privateKey, accountTo, summ) {
        const newTx = {
            accountFrom: accountFrom,
            accountTo: accountTo,
            value: summ
        }
        $.get(hostEthApi + '/' + newTx)
        .then(function(d) {
            summETHA = d.balance;
            //            summETHA = Eth3.fromWei(Eth3.eth.getBalance(addrsETHA), "ether");
            document.getElementById('aliceEthBalance').innerText = ' ' + summETHA.toFixed(3) + ' ';
        });

        var countTx = Eth3.eth.getTransactionCount(accountFrom);
        var value = Eth3.toHex(summ * 10 ** 18);
        var txParams = {
            nonce: countTx,
            gasPrice: gasPrice,
            gasLimit: gasLimit,
            to: accountTo,
            value: value,
            data: value0,
            // EIP 155 chainId - mainnet: 1, ropsten: 3, 1337 - private
            chainId: 4
        };

        var tx = new EthJS.Tx(txParams);
        tx.sign(privateKey);
        var serializedTx = tx.serialize();
        return '0x' + serializedTx.toString('hex')
    }

    function waitConfirmEth(hash) {
        var interval;
        var timeOut = setTimeout(function() {
            clearInterval(interval);
            showMess('Error while mining ETH Tx in next 5 minuts');
        }, 300000);
        interval = setInterval(function() {
            var block = Eth3.eth.getTransaction(hash);
            if (block != null & block.blockNumber > 0) {
                showMess('ETH Tx is confirmed in block ' + block.blockNumber);
                clearTimeout(timeOut);
                clearInterval(interval);
                nextStep();
                return
            }
        }, 5000);
    }
</script>