<script type="text/javascript">
    //  Initial values
    var valueBTC = valueETH = valueLIME = 0;
//    var summBTCA = summETHA = summLIMEA = 0; 
    alice = [0,0,0]
    var summBTCB = summETHB = summLIMEB = 0; //bob = alice
    
    var summBTCP = summETHP = summLIMEP = 0;
    var ethPriceBTC = ethPriceUSD = limePrice = 0;
    var nStr = stepN = orderID = 0;
    var timeNow = "";
    var value0 = 0;
    var gasLimit = 4700000;
//    var gasPrice = Lime3.toHex(25000000000);
    var gasPrice = 0;

    function nextStep() {
        stepN = stepN + 1;
        document.getElementById('ind').value = stepN;
        if (stepN == 1) {
            showMess("Smart contract DEx: startDEx in progress");
            document.getElementById('bobStatus').innerText = "Filling order: smart contract DEx in progress";
            document.getElementById('aliceStatus').innerText = "Filling order: smart contract DEx in progress";
            startDEx();
        } else if (stepN == 2) {
            var ff = semafor(1, 0, 0);
            showMess('Alice makes pledge Tx in Limes');
            var tx = makeLimeTX(addrsETHA, ethPrivateKeyA, addrsETHP, valueLIME);
            var ff = semafor(0, 0, 1);
            showMess("Plasmoid sends Alice's Tx to Limex");
            sendTx(addrsETHA, addrsETHP, tx);
        } else if (stepN == 3) {
            var ff = semafor(0, 1, 0);
            showMess('Bob makes pledge Tx in Limes');
            var tx = makeLimeTX(addrsETHB, ethPrivateKeyB, addrsETHP, valueLIME);
            var ff = semafor(0, 0, 1);
            showMess("Plasmoid sends Bob's Tx to Limex");
            sendTx(addrsETHB, addrsETHP, tx);
        } else if (stepN == 4) {
            showBalances();
            showMess('Smart contract DEx: inDepo in progress');
            callDExIn();
        } else if (stepN == 5) {
            var ff = semafor(1, 1, 0);
            showMess('Alice & Bob make two atomic swap Tx');
            atomicSwap();
        } else if (stepN == 6) {
            var ff = semafor(0, 0, 1);
            showBalances();
            document.getElementById('aliceStatus').innerText = "Alice received " + valueETH.toFixed(3) + " ETH";
            showMess("Atomic swap BTC/ETH in progress, waiting for BTC Tx confirmation");
        } else if (stepN == 7) {
            var ff = semafor(0, 0, 1);
            showBalances();
            showMess('Atomic swap is finished. Plasmoid makes Tx to cancel pledges');
            var tx = makeLimeTX(addrsETHP, ethPrivateKeyP, addrsETHA, valueLIME);
            showMess('Plasmoid sends ' + valueLIME.toFixed(3) + ' LIMEs to Alice');
            document.getElementById('bobStatus').innerText = "Bob received " + valueBTC.toFixed(6) + " BTC";
            sendTx(addrsETHP, addrsETHA, tx);
        } else if (stepN == 8) {
            showMess("Plasmoid makes Tx to cancel Bobs pledge");
            var tx = makeLimeTX(addrsETHP, ethPrivateKeyP, addrsETHB, valueLIME);
            showMess('Plasmoid sends ' + valueLIME.toFixed(3) + ' LIMEs to Bob');
            sendTx(addrsETHP, addrsETHB, tx);
        } else if (stepN == 9) {
            showMess('Smart contract DEx: outDepo in progress');
            callDExOut();
        } else if (stepN == 10) {
            var ff = semafor(0, 0, 0);
            showBalances();
            showMess("Atomic swap BTC/ETH finished successfully!");
        }
    };

    //  Lime functions  

    function startDEx() {
        orderID = 0;
        //        blockN = Lime3.eth.blockNumber;
        var filter = DExContract.StartDEx({
                maker: addrsETHA
            }
            /*    , {
                    fromBlock: blockN,
                    toBlock: 'latest'
                } */
        );
        //        console.log('set filter for contract event');
        filter.watch(function(err, event) {
            if (!err) {
                showMess('Smart contract DEx: startDEx Tx is successful');
                filter.stopWatching();
                console.log('order=' + event.args._order + ' from ' + event.args.maker + ' to ' + event.args.taker + ' via: ' + event.args.plasmoid + ' eth: ' + event.args.ethAmount / 10 ** 18 + ' btc: ' + event.args.btcAmount / 10 ** 8 + ' pledge (L): ' + event.args.pledgeLIMEAmount / 10 ** 9);
                orderID = event.args._order;
                nextStep();
            } else {
                console.log("Error " + err)
            };
        });
        showMess('Smart contract DEx: form and send startDEx Tx');
        var accountFrom = addrsETHB;
        var privateKey = ethPrivateKeyB;
        var myCallData = DExContract.openDEx.getData(addrsETHA, addrsETHP, valueETH * 10 ** 18, valueBTC * 10 ** 8, valueLIME * 10 ** 9); // Data for Ethereum transaction call smart contract DEx
        var accountTo = DExAddrs;
        var countTx = Lime3.eth.getTransactionCount(accountFrom);
        var txParams = {
            nonce: countTx,
            gasPrice: gasPrice,
            gasLimit: gasLimit,
            to: accountTo,
            value: value0,
            data: myCallData,
            // EIP 155 chainId - mainnet: 1, ropsten: 3, 1337 - private
            chainId: 1337
        }
        var tx = new EthJS.Tx(txParams);
        tx.sign(privateKey);
        var serializedTx = tx.serialize()
        Lime3.eth.sendRawTransaction('0x' + serializedTx.toString('hex'));
    }

    function sendTx(from, to, tx) {
        //        console.log('set filter for contract event Transfer');
        var filter = tokenContract.Transfer({
            from: from,
            to: to
        });
        filter.watch(function(err, event) {
            if (!err) {
                showMess('Transfer LIMEs Tx is successful');
                filter.stopWatching();
                nextStep();
            } else {
                console.log("Error tx " + err)
            };
        });
        Lime3.eth.sendRawTransaction(tx);
    }

    function callDExIn() {
        var filter = DExContract.InDepo({
            _order: orderID
        });
        filter.watch(function(err, event) {
            if (!err) {
                showMess('Smart contract DEx: inDepo Tx is successful');
                filter.stopWatching();
                console.log('order = ' + event.args._order);
                nextStep();
            } else {
                console.log("Error " + err)
            };
        });
        showMess('Smart contract DEx: form and send inDepo Tx, orderID= ' + orderID);
        var accountFrom = addrsETHP; //  Test RPC!!!
        var privateKey = ethPrivateKeyP;
        var myCallData = DExContract.inDepo.getData(orderID); // Data for Ethereum transaction call smart contract DEx
        var accountTo = DExAddrs;
        var countTx = Lime3.eth.getTransactionCount(accountFrom);
        var txParams = {
            nonce: countTx,
            gasPrice: gasPrice,
            gasLimit: gasLimit,
            to: accountTo,
            value: value0,
            data: myCallData,
            // EIP 155 chainId - mainnet: 1, ropsten: 3, 1337 - private
            chainId: 1337
        }
        var tx = new EthJS.Tx(txParams);
        tx.sign(privateKey);
        var serializedTx = tx.serialize()
        Lime3.eth.sendRawTransaction('0x' + serializedTx.toString('hex'));
    }

    function callDExOut() {
        var filter = DExContract.OutDepo({
            _order: orderID
        });
        filter.watch(function(err, event) {
            if (!err) {
                showMess('Smart contract DEx: OutDepo Tx is successful');
                filter.stopWatching();
                console.log('order = ' + event.args._order);
                nextStep();
            } else {
                console.log("Error " + err)
            };
        });
        showMess('Smart contract DEx: form and send OutDepo Tx');
        var accountFrom = addrsETHP;
        var privateKey = ethPrivateKeyP;
        var myCallData = DExContract.outDepo.getData(orderID, addrsETHP);
        var accountTo = DExAddrs;
        var countTx = Lime3.eth.getTransactionCount(accountFrom);
        var txParams = {
            nonce: countTx,
            gasPrice: gasPrice,
            gasLimit: gasLimit,
            to: accountTo,
            value: value0,
            data: myCallData,
            // EIP 155 chainId - mainnet: 1, ropsten: 3, 1337 - private
            chainId: 1337
        }
        var tx = new EthJS.Tx(txParams);
        tx.sign(privateKey);
        var serializedTx = tx.serialize()
        Lime3.eth.sendRawTransaction('0x' + serializedTx.toString('hex'));
    }

    function makeLimeTX(accountFrom, privateKey, spender, summ) {
        var accountTo = tokenAddrs;
        var countTx = Lime3.eth.getTransactionCount(accountFrom);
        var tokenBalance = tokenContract.balanceOf(accountFrom) / 10 ** 9;
        var myCallData = tokenContract.transfer.getData(spender, summ * 10 ** 9);
        var txParams = {
            nonce: countTx,
            gasPrice: gasPrice,
            gasLimit: gasLimit,
            to: accountTo,
            value: value0,
            data: myCallData,
            chainId: 1337
        }
        var tx = new EthJS.Tx(txParams);
        tx.sign(privateKey);
        var serializedTx = tx.serialize();
        return '0x' + serializedTx.toString('hex');
    }

    //  Atomic swap function
    function atomicSwap() {
        showMess('Alice send ' + valueBTC.toFixed(6) + 'BTC to Bob Tx to Bitcoin');
        makeBTCTx(addrsBTCA, wifPrivateKeyA, addrsBTCB, valueBTC * 10 ** 8, function(txHash) {
            showMess('BTC Tx is successful. Checking Bitcoin confirmation');
            console.log('BTC Tx hash: ' + txHash);
            var ff = semafor(3, 0, 1);
            waitConfirmBtc(txHash);
            /*            param = '?a=' + txHash //addrsFrom.toString();
                        $.post('/dex/checkTx' + param).done(function(ls) {
                            if (ls !== 'error') {
                                showMess('BTC Tx is confirmed in block ' + ls);
                                nextStep();
                            } else {
                                showMess('Error while BTC confirmation: no Tx mined in 30 min')
                            };
                        }).fail(function(xhr) {
                            showMess(xhr.responseText);
                        }); */
        });
        var tx = makeEthTX(addrsETHB, ethPrivateKeyB, addrsETHA, valueETH);
        showMess('Bob send ' + valueETH.toFixed(3) + 'ETH Tx to Ethereum');
        Eth3.eth.sendRawTransaction(tx, function(err, hash) {
            if (!err) {
                var ff = semafor(0, 3, 1);
                showMess('ETH Tx is success. Checking Ethereum confirmation');
                console.log('ETH Tx hash: ' + hash);
                waitConfirmEth(hash);
            } else
                showMess('Error while ETH Tx sends: ' + err);
        });
    }

    //  Bitcoin functions

    function makeBTCTx(addrsFrom, wifPrivateKey, addrsTo, value, callBack) {
        param = '?a=' + addrsFrom;
        param = param + '&b=' + addrsTo;
        //        valueBTC = document.getElementById('l_pct').value;
        param = param + '&c=' + value.toString();
        param = param + '&d=' + wifPrivateKey;
        $.post('/dex/tx' + param).done(function(ls) {
            console.log(ls);
            callBack(ls);
        }).fail(function(xhr) {
            showMess('Error while BTC Tx sends: ' + xhr.responseText);
        });
    }

    function waitConfirmBtc(hash) {
        var interval;
        var timeOut = setTimeout(function() {
            clearInterval(interval);
            showMess('Error while mining BTC Tx in next 30 minuts');
        }, 1800000);
        interval = setInterval(function() {
            $.get(hostBtc + '/txs/' + hash)
                .done(function(tx) {
                    if (tx.confirmations > 0) {
                        showMess('BTC Tx is confirmed in block ' + tx.block_height.toString());
                        clearTimeout(timeOut);
                        clearInterval(interval);
                        nextStep();
                    } //else //console.log(tx)
                })
                .fail(function(err) {
                    showMess('Error while mining BTC Tx: ' + err);
                })
        }, 30000);
    }

    //  Ethereum functions

    function makeEthTX(accountFrom, privateKey, accountTo, summ) {
        const newTx = {
            accountFrom: accountFrom,
            accountTo: accountTo,
            value: summ
        }
        $.get(hostEthApi + '/' + newTx)
        .then(function(d) {
            summETHA = d.balance;
            //            summETHA = Eth3.fromWei(Eth3.eth.getBalance(addrsETHA), "ether");
            document.getElementById('aliceEthBalance').innerText = ' ' + summETHA.toFixed(3) + ' ';
        });

        var countTx = Eth3.eth.getTransactionCount(accountFrom);
        var value = Eth3.toHex(summ * 10 ** 18);
        var txParams = {
            nonce: countTx,
            gasPrice: gasPrice,
            gasLimit: gasLimit,
            to: accountTo,
            value: value,
            data: value0,
            // EIP 155 chainId - mainnet: 1, ropsten: 3, 1337 - private
            chainId: 4
        };

        var tx = new EthJS.Tx(txParams);
        tx.sign(privateKey);
        var serializedTx = tx.serialize();
        return '0x' + serializedTx.toString('hex')
    }

    function waitConfirmEth(hash) {
        var interval;
        var timeOut = setTimeout(function() {
            clearInterval(interval);
            showMess('Error while mining ETH Tx in next 5 minuts');
        }, 300000);
        interval = setInterval(function() {
            var block = Eth3.eth.getTransaction(hash);
            if (block != null & block.blockNumber > 0) {
                showMess('ETH Tx is confirmed in block ' + block.blockNumber);
                clearTimeout(timeOut);
                clearInterval(interval);
                nextStep();
                return
            }
        }, 5000);
    }
</script>